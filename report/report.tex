%        File: report.tex
%
\documentclass[a4paper]{article}
\usepackage[pdftex]{graphicx}
\usepackage{float}
\usepackage{hyperref}
\floatstyle{ruled}
\newfloat{listing}{hbtH}{lop}
\floatname{listing}{Listing}
\renewcommand{\topfraction}{0.85}   % This sets the percentage for how much floats get from the ‘top’ of the text of a page
\renewcommand{\textfraction}{0}   % This sets a similar percentage for how much of a page needs to be text before no more floats can be placed on that page
\renewcommand{\floatpagefraction}{0.80} % This sets how much of the page must be taken by a float before that page can be ‘all’ floats

\author{Etienne Kneuss\\
\texttt{etienne.kneuss@epfl.ch}
}
\title{Static analysis for the PHP language}
\bibliographystyle{unsrt}
\begin{document}
\maketitle
\begin{abstract}
  This report presents the work that was done to implement a static analysis
  tool for the PHP programming language. This tool aims at providing feedback
  to a developer by checking for multiple mis-uses of the language and should
  reduce the risk of encountering fatal errors at runtime after deployement of
  PHP based application.
\end{abstract}
\section{Introduction}
The PHP programming language is a compiled language. However, the compilation is
done, by default, each time a certain php file is requested. This means that the
compilation has to be fast and hence can't do much analysis and checks. Most of
the checks are thus made at runtime. The purpose of this tool is to allow the
developer to check its work for runtime-errors, without actually running its
application. Those checks are mostly based on structural checks, coupled with
a stricter type-system.
\section{Design}
This tool consists of a custom PHP compiler, translating the code
into structures such as Abstract Syntax Trees (AST) and then Control Flow Graphs
(CFG). Fixpoint analysis is then performed on the CFGs. This compiler is
divided into six distinct parts:
\begin{enumerate}
  \item Lexing
  \item Parsing and Abstract Syntax Trees
  \item Semantic Analysis
  \item Crontrol Flow Graphs
  \item Type flow Analysis
  \item Helpers
\end{enumerate}

\subsection{Lexing}
The lexer uses a modified version of JFlex\footnote{JFlex: http://jflex.de}. It
is thus written in java. The original PHP compiler uses flex as scanner. The
modification done to JFlex is the implementation of flex's \verb=yymore()=,
which currently lacks in JFlex. This function is used to tell the scanner that
the following rules should be appended to \verb=yytext= instead of overwriting
it. The tokens generated are closely related to those PHP 5.3.0 would generate.
One notable difference is that we translated every single-char tokens to their
respective name.

\subsection{Parsing and Abstract Syntax Trees}
The parser, as mentionned before, is based on a modified version of CUP. CUP is
a java based parser generator which uses a syntax similar to yacc, the parser
generator used in the original PHP compiler. The version of CUP used for this
project differs from the original one in two points:
\begin{enumerate}
  \item The original CUP cannot handle large syntax files. Indeed, since CUP
    directly writes the parsing tables as properties of the generated class,
    the size of the class properties can become too large for \emph{javacc}. The
    PHP grammar being quite big, the resulting parser class couldn't be compiled.
    To solve the problem, CUP was modified to provide an option specifying that the
    the multiple tables should be written into files and loaded at runtime. This
    modification was proposed to be included inside CUP.
  \item To avoid the troubles of referencing scala classes, the parser
    generator was modified to translate the application of the production into a
    simple tree which could then be translated by a Scala class entirely.
\end{enumerate}

\subsection{Semantic Analysis}
Some checks can be done direcly by looking at the AST. Indeed, PHP provides a
wide range of features, some of them being considered nowadays as bad practice.
This tool emits notices for the following issues:

\begin{itemize}
  \item Non top-level declaration: PHP allows a developer to conditionnaly
    declare functions or classes. This not only generates problems with the
    following analysis, but also induces some performance hits on servers equipied
    with so-called opcode cachers. Those opcode cachers are responsible for caching
    the intermediate--or compiled version of each file, function and class. The
    goal being to speed up the process by reducing the number of compilations
    required per request. This cannot be done easily if those declarations are
    conditional.
  \item Call-time pass-by-ref: a function accepting a reference\footnote{PHP
    References: https://php.net/references} has to be defined as such, but PHP
    allows the developer to pass a reference at the time of the call, even to a
    function not declared to receive one. This feature is deprecated, and can cause
    unwanted side-effects.
  \item Non-trivial include calls: the \verb=include=\footnote{PHP Include:
    http://php.net/include} statement allows a developer to execute the given file
    in the current scope. The argument representing the file to include can be
    dynamic. This tool will try to resolve dynamic expressions that are most
    commonly used to be able to extend the analysis to that file. In case the
    expression is too dynamic, that include call will be ignored. Any
    combination of those expressions are considered as trivial dynamic expressions
    for include calls:
    \begin{itemize}
      \item the concatenation operator: "."
      \item the \verb=dirname()=\footnote{PHP dirname: http://php.net/dirname} function,
          used to retrieve the parent directory of the path passed as argument
      \item constants
      \item class constants
      \item string
    \end{itemize}
  \item Dynamic object properties: PHP allows dynamic references to an object property
    using a variable or expression (e.g. \verb.$name = "a"; $obj->$name. instead of
    \verb.$obj->a.). This is usually considered as bad practice since arrays are
    usually prefered for such tasks.
  \item Dynamic variables: PHP allows to reference a variable using either a
    variable, or an expression\footnote{PHP Variable variables:
    http://php.net/variables.variable}: (\verb=$$var= or
    \verb=${'prefix'.$name.foo()}=).
  \item Assignations in conditional expressions: assignations in PHP return the
    value assigned, they are hence valid expressions inside conditional
    expressions. However, history tells us that, most of the time, this is an
    actual typographic error replacing the assignation operator \verb&=& with
    the comparison operator \verb&==&. This tool will thus emit a warning if
    such expression is found inside an \verb&if()& or \verb&for()& condition.
    We exclude \verb&while()& on purpose as there is a common use-case where
    assignations are done directly inside the \verb&while()&
    expression\footnote{PHP mysql\_fetch\_assoc:
    http://php.net/mysql\_fetch\_assoc}.
\end{itemize}

Another part of the semantic analysis consists of validating the usage of
identifiers such as variables, functions or classes. The goal is to ensure that
no obvious semantic errors such as inheritance cycles, or visibility
inconsistances exist.

\subsubsection{API importation}
By default, PHP comes with a very dense library of functions and classes. In
fact, the main extensions that are shipped with PHP consist of more than 2'500
functions and classes. Being able to correctly represent this internal API is
a key factor to obtain useful analysis results. This API is stored in an external
XML file, allowing easy modifications and also do not require a re-compilation.
Additionally, a \verb=--apis= command line option is available to specify a
list of API files that can be imported into the symbol tables. This is especially
useful for large projects as it allows focused analysis.



\subsection{Control flow graphs}
In fact, the AST is only the intermediate step that only let us do trivial
checks. To analyse more complex aspects of a program, this tool will use
control flow graphs (CFG) which are derived from ASTs.  Control flow graphs
modelize the flow of values through the different control structures. Because
PHP is dynamically typed, and since variables are not declared, it is
impossible to infer and check types solely based on the structural
representation of the code. For such tasks, we require CFGs to be able to
reproduce the flow of types that would happen in an execution of the code. The
main focus of this analysis will be on analysing type flows.

\section{Analysis}
\subsection{PHP overview}
Before trying to see how to analyse PHP code, it is important to understand how PHP works,
this is a small overview of the features PHP provides that are relevant to this analysis.
\subsubsection{Types}
In PHP, we have the following types:
\begin{itemize}
  \item \textbf{Booleans}
  \item \textbf{Integers}
  \item \textbf{Floating point numbers}
  \item \textbf{Strings}
  \item \textbf{Arrays}: Arrays in PHP are ordered hashmaps, allowing either strings or
    integers as keys.  They can contain values of any type that may be mixed.
  \item \textbf{Objects}
  \item \textbf{Resources}: Resources represent special data types such as
    file handle, database conection links. They can be of different types. PHP
    extensions that define resource types are responsible of handling them
    appropriately.
  \item \textbf{Null}: This is the default type to any undefined or
    uninitialized variable.
\end{itemize}

Because PHP is loosely typed, it will do implicit type conversions\footnote{PHP
Type Juggling: php.net/language.types.type-juggling} with expressions invloving
mixed types. For example, \verb&2 + ``42''& is a valid expression that will
evaluate to $44$. Also, the type of any variable may change during the
execution.  For example, \verb&$a = 2; $a = new Foo();& is perfectly valid.

\subsubsection{Object Oriented Programing}
PHP supports OOP as of PHP4, but many features have later been added into PHP5.
The OO model as well as the syntax used is closely related to a subset of what
Java offers: public/protected/private visibility, single inheritance, with the
support of interfaces. PHP provides object properties, object methods, static
properties, static methods and class constants. You can dynamically define an
object property in PHP, its visibility will default to public. However, you
cannot dynamically define methods, static members, or constants.

\subsubsection{Limitations on analysis}
Due to its dynamicity, many PHP features will get in the way of a sound analysis.
Here is a non-exaustive list of such features:
\begin{itemize}
  \item \textbf{autoload}\footnote{PHP Autoload: http://php.net/autoload}:
    PHP allows you to trigger a function call in case an undefined class was
    used.  This function call is usually used to subsequently load the
    appropriate class at runtime. This feature allows programmers to only load
    classes on demand.
  \item \textbf{\_\_call}\footnote{PHP Overloading: http://php.net/\_\_call}:
    If a method call is defined in an object, calling an undefined method of
    that object will instead call the \verb&__call& method, with the name of
    the original method, and the arguments used.
  \item \textbf{\_\_callStatic}:
    This is similar to \verb&__call& but works for undefined static method
    calls.
  \item \textbf{\_\_get}\footnote{PHP Overloading: http://php.net/\_\_set}:
    This method will get called in case an access to an undefined object
    property is done. The value returned by the method will correspond to the
    property value.
  \item \textbf{ArrayAccess}\footnote{ArrayAccess Interface: http://php.net/arrayaccess}:
    The ArrayAccess interface allows an object to be used as an array. For example,
    if we have \verb&class Foo implements ArrayAccess&, then
    \verb&$foo = new Foo; echo $foo['index']& is accepted.
  \item \textbf{Dynamic accesses}
    PHP allows multiple ways to dynamically access variables, classes, members\ldots
    Here are a couple of examples:
    \begin{itemize}
      \item \verb/$$n/:
        Accesses the variable named by the value of \verb/$n/.
      \item \verb/$$$n/:
        Accesses the variable named by the value of \verb/$$n/.
      \item \verb/new $n()/:
        Constructs an object of the class named by the value of \verb/$n/.
      \item \verb/$c::$n()/:
        Call the static function named by the value of \verb/$n/ on the class
        named by the value of \verb/$n/.
      \item \verb/$n()/:
        Call the function named by the value of \verb/$n/.
    \end{itemize}
  \item \textbf{eval}\footnote{PHP Eval: http://php.net/eval}:
    The \verb&eval()& construct allows a developer to evaluate the code passed in as a string.
\end{itemize}

\subsection{Typeflow analysis}
As said earlier, the main focus of this analysis tool is on types. Even though
PHP is dynamically typed, and provides very few indications of types. It is
still interresting to try to infer types and check for type safety.

\subsubsection{Type mode}l
We now provide a detailled description of every elements of our type model:
\begin{itemize}
  \item \verb=TAny= ($\top$): Top of our lattice, represents any type
  \item \verb=TNone= ($\bot$): Bottom of our lattice, represents no type
  \item \verb=TBoolean=: Any boolean type.
  \item \verb=TFalse=, \verb=TTrue= : True/False types, used for conditional
    type filtering.
  \item \verb=TInt=: Integers
  \item \verb=TFloat=: Floating point numbers
  \item \verb=TResource=: Resources. We make no distinction between resources
    of different types. This could be improved in the future.
  \item \verb=TNull=: Null value.
  \item \verb=TString=: Strings
  \item \verb=TAnyArray=: This represents an array on which nothing is known
    appart from the fact that it's an array. Any lookup in this array will
    result in a type of \verb=TAny=.
  \item \verb=TArray=: This type represents an array on which a lot of information
    may be known. It is structured as follows:
    \begin{itemize}
        \item A index-type dictionnary for every well-defined entries. The rationale
          behind having such a precise representation is that PHP arrays are often
          used as containers for multiple named values. It is thus important to keep
          track of the types associated to each name.
        \item An optional array-wise type. This type represents the possible 
          contamination of an array via a dynamic access. This type is called
          the ``polluted type''. For exemple, the code
          \verb/$a[$foo] = 2/ will have the following effect on a well-defined
          array: First, every entries will get affected to indicate that the type
          might also be \verb=TInt=. Then, the polluted type is set (or expanded)
          to include \verb=TInt=. Having a polluted type defined for an array will
          shut down any notices of undefined array entries, as we are no longer sure
          whether a specific entry is defined or not.
    \end{itemize}
  \item Objects: Objects are represented differently than other types. The reason
    is that when passing, assigning or returning objects PHP will pass the 
    object reference. For example, in \verb/$a = new Foo; $b = $a; $a->foo = 2/,
    both \emph{\$a} and \emph{\$b} represent the same object, hence both
    variables are affected by the object modification. We need to reproduce
    that level of indirection as part of our type model for objects. This is
    done by introducing object references as types, mapping the real object in
    a an object store. That way the type can be copied around and propagated to
    different values and still point to the same real object type. We thus have
    two different levels of types:
    \begin{itemize}
          \item \textbf{Object references:} This is the type to which
            any well-defined object value is assigned.
          \item \textbf{Real objects:} The real object is pointed to by the
            object reference. This is the actual object type storing mapings to
            methods, properties and constants. It is stored in the ObjectStore
            and is not directly exposed as types of values.
    \end{itemize}

    Real objects are decomposed into two object types:
    \begin{itemize}
          \item \verb=TRealClassObject=: Representing an object of a
            defined class. This type will have, like arrays, a index-type
            mapping for properties. Since object properties can be dynamically
            defined, we also have a so-called polluted type for properties.
          \item \verb=TRealObject=: This is very similar to
            \verb=TRealClassObject=, the only difference is that this object
            carries no class. It is mostly used for type constructions. For
            instance, \verb/$a->b = 2/ will merge the type of \verb/$a/ with a
            constructed TRealObject having as only entry $(a \rightarrow
            TInt)$. This will result in a well defined object injected with $a
            \rightarrow TInt$. This specific area of the typechecker will be
            described in more details later.
    \end{itemize}
\end{itemize}

\subsubsection{Assigns to com}

\subsubsection{Conditional type filtering}
In PHP, most functions will return \verb/false/  or \verb/null/ in case of error.
For a function normally returning an integer, this means that any return value of this
function should be typed $TInt|TBoolean$. However, this would lead to massive amount of
false positives. Consider the following code which can be seen in most procedural code
dealing with mysql queries:

\begin{listing}
  \begin{verbatim}
<?php
$result = mysql_query(..);
if ($result) {
    while($row = mysql_fetch_assoc($result)) {
      ..
    }
}
?>
  \end{verbatim}
  \caption{Fetching query results}
\end{listing}

\verb/mysql_query/ either return a result resource or false in case the query
failed. \verb/mysql_fetch_assoc/ takes a resource, and return an array
representing the row, unless it reached the end of the result set in which case
it will return false. Naively checking types would give us many false positives:
\begin{itemize}
  \item \verb/mysql_fetch_assoc/'s argument would be of type
    $TBoolean \cup TResource$, which would fail with a type mismatch saying that it
    expects a $TResource$.
  \item Inside the while body, \verb/$row/ would still be of type
    $TBoolean \cup TArray$, generating a false positive for any usage of \verb/$row/
    as an array.
\end{itemize}

The solution to this problem is in two parts. First of all, it was necessary to
improve the precision of the boolean type and introduce $TTrue$ and $TFalse$. That
was, a function can be described as returning $TResource \cup TFalse$. From those
types, it becomes quite trivial to filter incompatible values when taking a branch.

For instance, with \verb/if ($result)/ the cfg will create two branches, one
for $\$result = true$ and one for $\$result \neq true$. In the first branch, we
can filter out types of \verb/$result/ that represent strictly false values,
which includes $TFalse$ and $TNull$. The same applies for the second branch,
in which we filter out strictly true values, namely $TTrue$ and $TResource$. In
our previous example, the type of \verb/$result/ inside the if body would thus
be filtered to $TResource$ which is correct. Moreover, it will also filter
assigns as conditionals, meaning that in 
\verb/while($row = mysql_fetch_assoc($result))/, the while body will have
$TResource$ for type of \verb/$row/. In summary, this simple filtering trick allows
for precise prototyping with reduced false-positives!

\subsection{Helpers}
In order to check that parts of the tool was working as expected, some helpers were
developped to retrieve information about each steps. The main helpers are able to generate:
\begin{itemize}
  \item A list of tokens generated from the file
  \item A dot file representing the Syntax Tree graph
  \item A dot file representing the Abstract Syntax Tree
  \item A dot file representing the Control Flow Graph, highlighting control structures
    such as \verb=if=, \verb=for=, \verb=foreach=, \verb=while=, \verb=dowhile=
\end{itemize}

Those helpers were used to generate the figures presented in this report.

\section{Limitations and future work}
As the timespan of this project was only one semester, only some limited
analysis has been done, and some shortcuts were taken. For example, PHP
references were ignored as they add much more complexity to the process, while
their usage is limited. Additionally, even though the code base for the syntax
is PHP 5.3, some of its features such as namespaces or closures has been left
out. The aim of this project being to provide something useful, some implementation
details were ignored, which means that the current codebase contains several
\emph{TODO} annotation, that would have to be looked over whenever some
additional time on this project.

Much more analysis could be done, such as value ranges analysis, that can help
guide the traversal of the CFG to gain precision. Also, the model used for
arrays could be precised to allow more fine-grained analysis.

\section{Conclusions}
This project was really interessant because it was based on a real language, used
every day by millions of users wolrdwide. Such a tool, once reaching stability
and soundness to some extent can make a considerable impact. However, due to the
number of lacks in the current implementation, the tool as-is wouldn't be of
much help in most cases. I hope that I'll find more time to work on it, either
on my free time or as a school-related project, because I feel that there is a
real gap to fill regarding static analysis of PHP related programs and scripts.

\addcontentsline{toc}{section}{References}
\begin{thebibliography}{99}
  \bibitem{tigerbook}A.W. Appel {\it Modern Compiler Implementation in Java}
    Cambridge University Press (2002)
  \bibitem{recdescent}\mbox{http://lara.epfl.ch/dokuwiki/compilation:} \mbox{example\_efficient\_code\_for\_conditionals}
\end{thebibliography}


\end{document}
